//! This is a bit of a weird one...
//!
//! We're using the rustdoc output to read and understand the source code for
//! `syn`, so that we can use `syn` to generate trait implementations for
//! `syn` structures.
//!
//! Usually, you'd just `#[derive(Merge)]` this, but that requires modifying
//! the source of `syn`, which we can't do since we want `syn-merge` to depend
//! on the published `syn`.
//!
//! Warning: This makes a few assumptions about the `syn` code structure,
//! which should be fine as this is only a helper script to generate the real
//! code.
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use rustdoc_types::{Crate, ItemEnum, StructKind};
use std::{
    collections::{BTreeMap, BTreeSet},
    fs,
    path::Path,
    process::Command,
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let repo_path = Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap();

    let status = Command::new(env!("CARGO"))
        .args(["doc", "--package=syn@2.0.43", "--no-deps"])
        .env("RUSTDOCFLAGS", "-Zunstable-options --output-format=json")
        .status()?;
    assert!(status.success());

    let path = repo_path.join("target").join("doc").join("syn.json");
    let data = fs::read_to_string(path)?;
    let krate: Crate = serde_json::from_str(&data)?;
    let index = krate.index;

    let mut output = TokenStream::new();
    output.extend(quote! {
        //! Automatically generated by `cargo run --bin=generate`.
    });

    // let ItemEnum::Module(root_module) = &dbg!(&index[&krate.root]).inner else {
    //     unreachable!("root module")
    // };
    let mut structs = BTreeMap::new();
    let mut enums = BTreeMap::new();
    for item in index.values() {
        let name = item.name.as_deref().unwrap_or_default();
        let allowlist = &[
            "Abi",
            "Arm",
            "Block",
            "FnArg",
            "ImplRestriction",
            "Local",
            "LocalInit",
            "Receiver",
            "Signature",
            "StmtMacro",
            "Variadic",
            "Variant",
        ];
        if name.starts_with("Expr")
            || (name.starts_with("Field") && name != "Fields" && name != "FieldMutability")
            || name.starts_with("ForeignItem")
            || name.starts_with("ImplItem")
            || name.starts_with("Item")
            || name.starts_with("Meta")
            || (name.starts_with("Pat") && !name.starts_with("Path"))
            || name.starts_with("TraitItem")
            || allowlist.contains(&name)
        {
            match &item.inner {
                ItemEnum::Struct(s) => {
                    let StructKind::Plain { fields, .. } = &s.kind else {
                        panic!("struct kind plain")
                    };
                    structs.insert(name, fields);
                }
                ItemEnum::Enum(e) => {
                    let is_non_exhaustive = item.attrs.contains(&"#[non_exhaustive]".to_string());
                    enums.insert(name, (is_non_exhaustive, &e.variants));
                }
                ItemEnum::AssocType { .. } => {}
                ItemEnum::Variant { .. } => {}
                _ => unreachable!("{item:?}"),
            }
        }
    }

    for (name, (is_non_exhaustive, variant_ids)) in enums {
        let variants = variant_ids.iter().map(|id| {
            let variant = &index[id];
            format_ident!("{}", variant.name.as_deref().unwrap())
        });
        let name = format_ident!("{name}");
        let non_exhaustive = if is_non_exhaustive {
            quote!(_,)
        } else {
            quote!()
        };
        output.extend(quote! {
            impl_merge_enum! {
                syn::#name {
                    #(#variants,)*
                    #non_exhaustive
                }
            }
        });
    }

    for (name, fields) in structs {
        let mut has_attrs = false;
        let fields: Vec<_> = fields
            .iter()
            .map(|id| index[id].name.as_deref().unwrap())
            .inspect(|name| {
                if *name == "attrs" {
                    has_attrs = true;
                }
            })
            .map(|name| format_ident!("{name}"))
            .collect();
        let name = format_ident!("{name}");
        let add_attr = if has_attrs {
            quote!(#[attrs])
        } else {
            quote!()
        };
        output.extend(quote! {
            impl_merge_struct! {
                #add_attr
                syn::#name {
                    #(#fields,)*
                }
            }
        });
    }

    let tokens_module = index
        .iter()
        .find_map(|(_, item)| {
            if item.name.as_deref() == Some("token") {
                if let ItemEnum::Module(module) = &item.inner {
                    Some(module)
                } else {
                    None
                }
            } else {
                None
            }
        })
        .expect("find token module");
    let mut token_names = BTreeSet::new();
    for token_id in &tokens_module.items {
        let item = &index[token_id];
        if let ItemEnum::Struct(_) = &item.inner {
            token_names.insert(item.name.as_deref().expect("token struct name"));
        }
    }
    for name in token_names {
        let name = format_ident!("{name}");
        output.extend(quote! {
            impl_merge_eq!(syn::token::#name);
        });
    }

    let output_path = repo_path
        .join("syn-merge")
        .join("src")
        .join("syn_impl_generated.rs");

    fs::write(
        output_path,
        prettyplease::unparse(&syn::parse_file(&format!("{output}"))?),
    )?;

    Ok(())
}
